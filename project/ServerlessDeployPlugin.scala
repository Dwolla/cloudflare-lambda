import cats.syntax.either._
import com.typesafe.sbt.packager.universal.UniversalPlugin
import com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._
import io.circe.yaml.parser
import sbt.Keys.{baseDirectory, packageBin}
import sbt.internal.util.complete.DefaultParsers._
import sbt.internal.util.complete.Parser
import sbt.{Def, settingKey, IO => SbtIO, _}

import scala.sys.process._


// Before utilizing Serverless, this stack used the plugin sbt-cloudformation-stack for generating its CloudFormation
// template: https://github.com/Dwolla/sbt-cloudformation-stack. A problem arose when migrating to Serverless. The
// CloudFormation template generated by the sbt-cloudformation-stack uses logical names that are different than those
// created by Serverless (sbt-cloudformation-stack uses the logical name Function for the Lambda function, whereas
// Serverless forces it to be CloudflareLambdaFunction.) Serverless offers no way to override this naming scheme.
//
// The Lambda function name is exported, so when the stack is updated if the Lambda function's logical name has
// changed Cloudformation will not allow the update to proceed if the export is referenced by other stacks. The code
// below addresses this by ensuring that even though we are using Serverless the logical name for the Lambda function
// remains the same.
object ServerlessDeployPlugin extends AutoPlugin {
  object autoImport {
    val serverlessPackageCommand = settingKey[Seq[String]]("serverless command to package the application")
    val uploadToS3Command = settingKey[Seq[String]]("command to upload cloudformation template to S3")
    val cloudformationDeployCommand = settingKey[Seq[String]]("cloudformation command to deploy the application")
    val prepare = inputKey[Int]("package the Serverless service")
    val deploy = inputKey[Int]("deploy to AWS")
  }

  import autoImport._

  override def trigger: PluginTrigger = NoTrigger

  override def requires: Plugins = UniversalPlugin

  override lazy val projectSettings = Seq(
    serverlessPackageCommand := "serverless package --verbose".split(' ').toSeq,
    uploadToS3Command := "aws s3 cp".split(' ').toSeq,
    cloudformationDeployCommand := "aws cloudformation deploy --capabilities CAPABILITY_NAMED_IAM".split(' ').toSeq,

    prepare := Def.inputTask {
      val stage = Stage.parser.parsed.name.toLowerCase
      val artifactPath = (Universal / packageBin).value.toString

      val serverlessExitCode = Process(
        serverlessPackageCommand.value ++ Seq("--stage", stage),
        Option((ThisBuild / baseDirectory).value),
        "ARTIFACT_PATH" -> artifactPath,
      ).!

      if (serverlessExitCode == 0) serverlessExitCode
      else throw new IllegalStateException("Serverless returned a non-zero exit code. Please check the logs for more" +
        " information.")
    }.evaluated,

    deploy := Def.inputTask {
      val artifactPath = (Universal / packageBin).value.toString
      val cloudformationTemplatePath = (ThisBuild / baseDirectory).value /
        ".serverless" / "cloudformation-template-update-stack.json"

      val updatedCloudformationTemplate = SbtIO.read(cloudformationTemplatePath).replaceAll("CloudflareLambdaFunction",
        "Function")
      SbtIO.write(
        cloudformationTemplatePath,
        updatedCloudformationTemplate
      )

      val stackNameCursor = for {
        doc <- parser.parse(SbtIO.read((ThisBuild / baseDirectory).value / "serverless.yml"))
        cursor = doc.hcursor
        provider <- cursor.downField("provider").downField("stackName").as[String]
      } yield provider

      val stackName = stackNameCursor.valueOr(_ => throw new IllegalStateException("Unable to parse stack name from " +
        "serverless.yml. Please verify it exists."))

      val artifactS3PathCursor = for {
        doc <- parser.parse(updatedCloudformationTemplate)
        cursor = doc.hcursor.downField("Resources").downField("Function").downField("Properties").downField("Code")
        artifactS3Bucket <- cursor.downField("S3Bucket").as[String]
        artifactS3Key <- cursor.downField("S3Key").as[String]
      } yield (artifactS3Bucket, artifactS3Key)

      val artifactS3Path = artifactS3PathCursor.valueOr(_ => throw new IllegalStateException("Unable to parse " +
        "artifact S3 path. Please check the generated Cloudformation template in .serverless to verify it exists."))

      val uploadToS3ExitCode = Process(
        "aws s3 cp ".split(' ').toSeq ++ Seq(artifactPath, s"s3://${artifactS3Path._1}/${artifactS3Path._2}")
      ).!

      if (uploadToS3ExitCode != 0) throw new IllegalStateException("Failed to upload the artifact to S3.")

      val cloudformationExitCode = Process(
        cloudformationDeployCommand.value ++ Seq("--template-file", cloudformationTemplatePath.getPath) ++
          s"--stack-name $stackName".split(' ').toSeq,
        Option((ThisBuild / baseDirectory).value)
      )!

      if (cloudformationExitCode == 0) cloudformationExitCode
      else throw new IllegalStateException("Cloudformation returned a non-zero exit code ($cloudformationExitCode). " +
        "Please check the logs for more information.")
    }.evaluated
  )

  sealed abstract class Stage(val name: String) {
    val parser: Parser[this.type] = (Space ~> token(this.toString)).map(_ => this)
  }

  object Stage {
    val parser: Parser[Stage] =
      token(Stage.Sandbox.parser) |
        token(Stage.DevInt.parser) |
        token(Stage.Uat.parser) |
        token(Stage.Prod.parser) |
        token(Stage.Admin.parser)

    case object Sandbox extends Stage("Sandbox")
    case object DevInt extends Stage("DevInt")
    case object Uat extends Stage("Uat")
    case object Prod extends Stage("Prod")
    case object Admin extends Stage("Admin")
  }
}

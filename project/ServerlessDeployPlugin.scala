
import com.typesafe.sbt.packager.universal.UniversalPlugin
import com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._
import io.circe.yaml.parser
import cats.syntax.either._
import sbt.Keys.{baseDirectory, packageBin}
import sbt.internal.util.complete.DefaultParsers._
import sbt.internal.util.complete.Parser
import sbt.{Def, settingKey, IO => SbtIO, _}

import scala.sys.process._


// Before utilizing Serverless, this stack used the plugin sbt-cloudformation-stack for generating its CloudFormation
// template: https://github.com/Dwolla/sbt-cloudformation-stack. A problem arose when migrating to Serverless. The
// CloudFormation template generated by the sbt-cloudformation-stack uses logical names that are different than those
// created by Serverless (sbt-cloudformation-stack uses the logical name Function for the Lambda function, whereas
// Serverless forces it to be CloudflareLambdaFunction.) Serverless offers no way to override this naming scheme.
//
// The Lambda function name is exported. So, when the stack is updated, if the Lambda function's logical name has
// changed (or certain other properties of the lambda) Cloudformation will not allow the update to proceed if the export
// is referenced by other stacks. The code below addresses this by ensuring that even though we are using Serverless
// the logical name for the Lambda function remains the same.
object ServerlessDeployPlugin extends AutoPlugin {
  object autoImport {
    val serverlessPackageCommand = settingKey[Seq[String]]("serverless command to package the application")
    val cloudformationDeployCommand = settingKey[Seq[String]]("cloudformation command to deploy the application")
    val prepare = inputKey[Unit]("package the Serverless service")
    val deploy = inputKey[Int]("deploy to AWS")
  }

  import autoImport._

  override def trigger: PluginTrigger = NoTrigger

  override def requires: Plugins = UniversalPlugin

  def updateCloudformationTemplate(cloudformationTemplate: String) = {
    val withLambdaLogicalNameReplaced = cloudformationTemplate.replaceAll("CloudflareLambdaFunction",
      "Function")

    val doc = parser.parse(withLambdaLogicalNameReplaced).valueOr(_ => throw new IllegalStateException("Unable to " +
      "parse the generated Cloudformation template."))

    val withFunctionNameDeleted = doc.hcursor.downField("Resources").downField("Function").downField("Properties")
      .downField("FunctionName").delete.root
    val withLambdaVersionDeleted = withFunctionNameDeleted.downField("Resources").withFocus(
      _.mapObject(
        _.filter {
          case (_, v) => v.hcursor.downField("Type").as[String].map(_ != "AWS::Lambda::Version").getOrElse(true)
        }
      )
    ).root
    val withFunctionQualifiedArnOutputDeleted = withLambdaVersionDeleted.downField("Outputs")
      .downField("FunctionQualifiedArn").delete.root

    withFunctionQualifiedArnOutputDeleted.top.getOrElse(doc).spaces2
  }

  def parseServerlessProviderInfo(serverlessFile: String): Option[ServerlessProviderInfo] = {
    for {
      doc <- parser.parse(serverlessFile)
      cursor = doc.hcursor.downField("provider")
      region <- cursor.downField("region").as[String]
      stackName <- cursor.downField("stackName").as[String]
    } yield ServerlessProviderInfo(region, stackName)
  }.toOption

  def parseArtifactS3Path(cloudformationTemplate: String): Option[String] = {
    for {
      doc <- parser.parse(cloudformationTemplate)
      cursor = doc.hcursor.downField("Resources").downField("Function").downField("Properties").downField("Code")
      artifactS3Bucket <- cursor.downField("S3Bucket").as[String]
      artifactS3Key <- cursor.downField("S3Key").as[String]
    } yield s"s3://$artifactS3Bucket/$artifactS3Key"
  }.toOption

  override lazy val projectSettings = Seq(
    serverlessPackageCommand := "serverless package --verbose".split(' ').toSeq,
    cloudformationDeployCommand := "aws cloudformation deploy --capabilities CAPABILITY_NAMED_IAM".split(' ').toSeq,

    prepare := Def.inputTask {
      val stage = Stage.parser.parsed.name.toLowerCase
      val artifactPath = (Universal / packageBin).value.toString
      val cloudformationTemplatePath = (ThisBuild / baseDirectory).value /
        ".serverless" / "cloudformation-template-update-stack.json"

      val serverlessExitCode = Process(
        serverlessPackageCommand.value ++ Seq("--stage", stage),
        Option((ThisBuild / baseDirectory).value),
        "ARTIFACT_PATH" -> artifactPath,
      ).!

      if (serverlessExitCode != 0) throw new IllegalStateException("Serverless returned a non-zero exit code. Please" +
        " check the logs for more information.")

      SbtIO.write(
        cloudformationTemplatePath,
        updateCloudformationTemplate(SbtIO.read(cloudformationTemplatePath))
      )
    }.evaluated,

    deploy := Def.inputTask {
      val artifactPath = (Universal / packageBin).value.toString
      val cloudformationTemplatePath = (ThisBuild / baseDirectory).value /
        ".serverless" / "cloudformation-template-update-stack.json"

      val serverlessProviderInfo = parseServerlessProviderInfo(SbtIO.read((ThisBuild / baseDirectory).value /
        "serverless.yml")).getOrElse(throw new IllegalStateException("Unable to parse stack name and/or region from " +
        "serverless.yml. Please verify they exist."))

      val artifactS3Path = parseArtifactS3Path(SbtIO.read(cloudformationTemplatePath)).getOrElse(throw new
          IllegalStateException ("Unable to parse artifact S3 path. Please check the generated Cloudformation " +
            "template in .serverless to verify it exists."))

      val uploadToS3ExitCode = Process(
        s"aws s3 cp --region ${serverlessProviderInfo.region}".split(' ').toSeq ++ Seq(artifactPath, artifactS3Path)
      ).!

      if (uploadToS3ExitCode != 0) throw new IllegalStateException("Failed to upload the artifact to S3.")

      val cloudformationExitCode = Process(
        cloudformationDeployCommand.value ++ Seq("--template-file", cloudformationTemplatePath.getPath) ++
          s"--stack-name ${serverlessProviderInfo.stackName} --region ${serverlessProviderInfo.region}".split(' ')
            .toSeq,
        Option((ThisBuild / baseDirectory).value)
      ).!

      if (cloudformationExitCode == 0) cloudformationExitCode
      else throw new IllegalStateException(s"Cloudformation returned a non-zero exit code ($cloudformationExitCode). " +
        "Please check the logs for more information.")
    }.evaluated
  )

  case class ServerlessProviderInfo(region: String, stackName: String)

  sealed abstract class Stage(val name: String) {
    val parser: Parser[this.type] = (Space ~> token(this.toString)).map(_ => this)
  }

  object Stage {
    val parser: Parser[Stage] =
      token(Stage.Sandbox.parser) |
        token(Stage.DevInt.parser) |
        token(Stage.Uat.parser) |
        token(Stage.Prod.parser) |
        token(Stage.Admin.parser)

    case object Sandbox extends Stage("Sandbox")
    case object DevInt extends Stage("DevInt")
    case object Uat extends Stage("Uat")
    case object Prod extends Stage("Prod")
    case object Admin extends Stage("Admin")
  }
}
